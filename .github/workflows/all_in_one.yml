name: All-in-One Orchestrator

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: "Intentionally fail after everything runs (prevents successful completion)."
        type: boolean
        required: false
        default: false
      dry_run:
        description: "Do not dispatch downstream workflows; only print what would happen."
        type: boolean
        required: false
        default: true

permissions:
  actions: write   # required to dispatch other workflows
  contents: write  # your inline sed steps do commits/pushes if you add them later
  checks: read
  deployments: write

env:
  TEST_MODE: ${{ inputs.test_mode }}
  DRY_RUN: ${{ inputs.dry_run }}
  OWNER: RoundSalmon4
  REPO: blended-strawberry
  REF: master

jobs:
  # Utility job to show run flags
  echo_flags:
    name: Echo flags
    runs-on: ubuntu-latest
    steps:
      - name: Echo TEST_MODE and DRY_RUN
        run: |
          echo "TEST_MODE=${{ env.TEST_MODE }}"
          echo "DRY_RUN=${{ env.DRY_RUN }}"

  # 1) UPDATE
  dispatch_update:
    name: Dispatch update.yml and wait
    runs-on: ubuntu-latest
    needs: echo_flags
    steps:
      - name: Dry-run no-op
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/update.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait for update.yml
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const ref = process.env.REF;
            const workflowFile = '.github/workflows/update.yml';

            // 1) Create a time anchor to identify new runs
            const startAt = new Date().toISOString();

            // 2) Dispatch the workflow (workflow_dispatch)
            await github.rest.actions.createWorkflowDispatch({
              owner, repo,
              workflow_id: workflowFile,
              ref,
              inputs: {} // no inputs since you don't want to edit the callee
            });

            // 3) Poll for the newly triggered run to appear and finish
            const wait = ms => new Promise(res => setTimeout(res, ms));
            const timeoutMs = 30 * 60 * 1000; // 30 min
            const pollEveryMs = 10 * 1000;    // 10s
            const deadline = Date.now() + timeoutMs;
            let runId = null;

            // Find the newest run for this workflow that started after we dispatched
            while (Date.now() < deadline && !runId) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner, repo,
                workflow_id: workflowFile,
                event: 'workflow_dispatch',
                branch: ref,
                per_page: 10
              });
              const candidate = data.workflow_runs.find(r => new Date(r.created_at) >= new Date(startAt));
              if (candidate) {
                runId = candidate.id;
                core.info(`Found run id ${runId}`);
                break;
              }
              core.info('Waiting for run to be created...');
              await wait(pollEveryMs);
            }

            if (!runId) {
              core.setFailed('Timed out waiting for dispatched run to appear');
              return;
            }

            // Now wait for completion
            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner, repo, run_id: runId
              });
              core.info(`Run status=${run.status}, conclusion=${run.conclusion || ''}`);
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') {
                  core.setFailed(`Dispatched workflow concluded with status: ${run.conclusion}`);
                }
                return;
              }
              await wait(pollEveryMs);
            }
            core.setFailed('Timed out waiting for dispatched workflow to complete');

  # 2) Modify INCLUDE_GIT_REVISION (inline)
  modify_git_revision:
    name: Modify Git Revision
    runs-on: ubuntu-latest
    needs: dispatch_update
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.REF }}

      - name: Set INCLUDE_GIT_REVISION to OFF
        shell: bash
        run: |
          sed -i 's/set(INCLUDE_GIT_REVISION ON)/set(INCLUDE_GIT_REVISION OFF)/' cmake/Version.cmake
          echo "File updated. (Commit/push as needed — omitted here to keep parity with your previous flow)"

  # 3) BUILD
  dispatch_build:
    name: Dispatch build.yml and wait
    runs-on: ubuntu-latest
    needs: modify_git_revision
    steps:
      - name: Dry-run no-op
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/build.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait for build.yml
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const ref = process.env.REF;
            const workflowFile = '.github/workflows/build.yml';
            const startAt = new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflowFile, ref, inputs: {} });
            const wait = ms => new Promise(res => setTimeout(res, ms));
            const timeoutMs = 30 * 60 * 1000, pollEveryMs = 10000, deadline = Date.now() + timeoutMs;
            let runId = null;
            while (Date.now() < deadline && !runId) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner, repo, workflow_id: workflowFile, event: 'workflow_dispatch', branch: ref, per_page: 10
              });
              const candidate = data.workflow_runs.find(r => new Date(r.created_at) >= new Date(startAt));
              if (candidate) { runId = candidate.id; break; }
              await wait(pollEveryMs);
            }
            if (!runId) { core.setFailed('Timed out waiting for build run'); return; }
            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') core.setFailed(`Build concluded: ${run.conclusion}`);
                return;
              }
              await wait(pollEveryMs);
            }
            core.setFailed('Timed out waiting for build to complete');

  # 4) CODEBERG SYNC
  dispatch_codeberg:
    name: Dispatch codeberg.yml and wait
    runs-on: ubuntu-latest
    needs: dispatch_build
    steps:
      - name: Dry-run no-op
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait for codeberg.yml
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER, repo = process.env.REPO, ref = process.env.REF;
            const workflowFile = '.github/workflows/codeberg.yml';
            const startAt = new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflowFile, ref, inputs: {} });
            const wait = ms => new Promise(res => setTimeout(res, ms));
            const deadline = Date.now() + 30*60*1000, poll = 10000;
            let runId = null;
            while (Date.now() < deadline && !runId) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner, repo, workflow_id: workflowFile, event: 'workflow_dispatch', branch: ref, per_page: 10
              });
              const candidate = data.workflow_runs.find(r => new Date(r.created_at) >= new Date(startAt));
              if (candidate) runId = candidate.id; else await wait(poll);
            }
            if (!runId) { core.setFailed('Timed out waiting for codeberg run'); return; }
            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') core.setFailed(`Codeberg concluded: ${run.conclusion}`);
                return;
              }
              await wait(poll);
            }
            core.setFailed('Timed out waiting for codeberg to complete');

  # 5) CODEBERG RELEASE
  dispatch_codeberg_release:
    name: Dispatch codeberg_release.yml and wait
    runs-on: ubuntu-latest
    needs: dispatch_codeberg
    steps:
      - name: Dry-run no-op
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg_release.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait for codeberg_release.yml
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER, repo = process.env.REPO, ref = process.env.REF;
            const workflowFile = '.github/workflows/codeberg_release.yml';
            const startAt = new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflowFile, ref, inputs: {} });
            const wait = ms => new Promise(res => setTimeout(res, ms));
            const deadline = Date.now() + 30*60*1000, poll = 10000;
            let runId = null;
            while (Date.now() < deadline && !runId) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner, repo, workflow_id: workflowFile, event: 'workflow_dispatch', branch: ref, per_page: 10
              });
              const candidate = data.workflow_runs.find(r => new Date(r.created_at) >= new Date(startAt));
              if (candidate) runId = candidate.id; else await wait(poll);
            }
            if (!runId) { core.setFailed('Timed out waiting for codeberg_release run'); return; }
            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') core.setFailed(`Codeberg release concluded: ${run.conclusion}`);
                return;
              }
              await wait(poll);
            }
            core.setFailed('Timed out waiting for codeberg_release to complete');

  # 6) CODEBERG NOTES
  dispatch_codeberg_notes:
    name: Dispatch codeberg_notes.yml and wait
    runs-on: ubuntu-latest
    needs: dispatch_codeberg_release
    steps:
      - name: Dry-run no-op
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg_notes.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait for codeberg_notes.yml
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER, repo = process.env.REPO, ref = process.env.REF;
            const workflowFile = '.github/workflows/codeberg_notes.yml';
            const startAt = new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflowFile, ref, inputs: {} });
            const wait = ms => new Promise(res => setTimeout(res, ms));
            const deadline = Date.now() + 30*60*1000, poll = 10000;
            let runId = null;
            while (Date.now() < deadline && !runId) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner, repo, workflow_id: workflowFile, event: 'workflow_dispatch', branch: ref, per_page: 10
              });
              const candidate = data.workflow_runs.find(r => new Date(r.created_at) >= new Date(startAt));
              if (candidate) runId = candidate.id; else await wait(poll);
            }
            if (!runId) { core.setFailed('Timed out waiting for codeberg_notes run'); return; }
            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') core.setFailed(`Codeberg notes concluded: ${run.conclusion}`);
                return;
              }
              await wait(poll);
            }
            core.setFailed('Timed out waiting for codeberg_notes to complete');

  # Reset INCLUDE_GIT_REVISION (inline)
  reset_git_revision:
    name: Reset Git Revision
    runs-on: ubuntu-latest
    needs: dispatch_codeberg_notes
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.REF }}

      - name: Set INCLUDE_GIT_REVISION to ON
        shell: bash
        run: |
          sed -i 's/set(INCLUDE_GIT_REVISION OFF)/set(INCLUDE_GIT_REVISION ON)/' cmake/Version.cmake
          echo "File updated. (Commit/push as needed — omitted here to keep parity with your previous flow)"

  # Final: fail intentionally if test mode is enabled
  fail_if_test_mode:
    name: Fail run if TEST_MODE is true
    runs-on: ubuntu-latest
    needs:
      - dispatch_update
      - modify_git_revision
      - dispatch_build
      - dispatch_codeberg
      - dispatch_codeberg_release
      - dispatch_codeberg_notes
      - reset_git_revision
    if: always()
    steps:
      - name: Check TEST_MODE and optionally fail
        shell: bash
        run: |
          echo "TEST_MODE=${{ env.TEST_MODE }}"
          if [ "${{ env.TEST_MODE}" = "true" ]; then
            echo "Global test mode enabled: intentionally failing at the end."
            exit 1
          else
            echo "Global test mode disabled: finishing successfully."
          fi
