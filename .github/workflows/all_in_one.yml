name: All-in-One Orchestrator

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: "Intentionally fail after everything runs (prevents successful completion)."
        type: boolean
        required: false
        default: false
      dry_run:
        description: "Do not dispatch downstream workflows; only print what would happen."
        type: boolean
        required: false
        default: true

permissions:
  actions: write   # required to dispatch and read workflow runs
  contents: write  # inline steps may modify files if you later add commits
  checks: read
  deployments: write

env:
  TEST_MODE: ${{ inputs.test_mode }}
  DRY_RUN: ${{ inputs.dry_run }}
  OWNER: RoundSalmon4
  REPO: blended-strawberry
  REF: master

jobs:
  echo_flags:
    name: Echo flags
    runs-on: ubuntu-latest
    steps:
      - name: Echo TEST_MODE and DRY_RUN
        run: |
          echo "TEST_MODE=${{ env.TEST_MODE }}"
          echo "DRY_RUN=${{ env.DRY_RUN }}"

  # A. UPDATE
  dispatch_update:
    name: Dispatch update.yml and wait
    runs-on: ubuntu-latest
    needs: echo_flags
    steps:
      - name: Dry-run no-op (update)
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/update.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait (update.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        env:
          WORKFLOW_FILE: .github/workflows/update.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER;
            const repo  = process.env.REPO;
            const ref   = process.env.REF;
            const workflowFile = process.env.WORKFLOW_FILE;

            const wait = ms => new Promise(res => setTimeout(res, ms));
            const timeoutMs  = 30 * 60 * 1000; // 30 minutes
            const pollEvery  = 10 * 1000;      // 10 seconds
            const deadline   = Date.now() + timeoutMs;
            const startAtIso = new Date().toISOString();

            // Dispatch
            await github.rest.actions.createWorkflowDispatch({
              owner, repo, workflow_id: workflowFile, ref, inputs: {}
            });

            // Find the new run created after startAtIso
            let runId = null;
            while (Date.now() < deadline && !runId) {
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRuns,
                { owner, repo, workflow_id: workflowFile, event: 'workflow_dispatch', branch: ref, per_page: 50 }
              );
              const candidate = runs.find(r => new Date(r.created_at) >= new Date(startAtIso));
              if (candidate) {
                runId = candidate.id;
                core.info(`Dispatched run id: ${runId}`);
                break;
              }
              core.info('Waiting for dispatched run to be created...');
              await wait(pollEvery);
            }
            if (!runId) {
              core.setFailed(`Timed out waiting for ${workflowFile} run to appear`);
              return;
            }

            // Wait for completion
            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              core.info(`status=${run.status}, conclusion=${run.conclusion ?? ''}`);
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') core.setFailed(`${workflowFile} concluded: ${run.conclusion}`);
                return;
              }
              await wait(pollEvery);
            }
            core.setFailed(`Timed out waiting for ${workflowFile} to complete`);

  # B. Modify INCLUDE_GIT_REVISION (inline)
  modify_git_revision:
    name: Modify Git Revision
    runs-on: ubuntu-latest
    needs: dispatch_update
    steps:
      - name: Dry-run no-op (modify)
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would modify cmake/Version.cmake to set INCLUDE_GIT_REVISION=OFF"

      - name: Checkout Code
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ env.REF }}

      - name: Set INCLUDE_GIT_REVISION to OFF
        if: ${{ env.DRY_RUN != 'true' }}
        shell: bash
        run: |
          sed -i 's/set(INCLUDE_GIT_REVISION ON)/set(INCLUDE_GIT_REVISION OFF)/' cmake/Version.cmake
          echo "File updated. (Commit/push omitted to mirror your earlier flow)"

  # C. BUILD
  dispatch_build:
    name: Dispatch build.yml and wait
    runs-on: ubuntu-latest
    needs: modify_git_revision
    steps:
      - name: Dry-run no-op (build)
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/build.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait (build.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        env:
          WORKFLOW_FILE: .github/workflows/build.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER, repo = process.env.REPO, ref = process.env.REF;
            const workflowFile = process.env.WORKFLOW_FILE;
            const wait = ms => new Promise(res => setTimeout(res, ms));
            const timeoutMs=30*60*1000, pollEvery=10000, deadline=Date.now()+timeoutMs;
            const startAtIso = new Date().toISOString();

            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflowFile, ref, inputs: {} });

            let runId = null;
            while (Date.now() < deadline && !runId) {
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRuns,
                { owner, repo, workflow_id: workflowFile, event: 'workflow_dispatch', branch: ref, per_page: 50 }
              );
              const candidate = runs.find(r => new Date(r.created_at) >= new Date(startAtIso));
              if (candidate) runId = candidate.id; else await wait(pollEvery);
            }
            if (!runId) { core.setFailed(`Timed out waiting for ${workflowFile} run`); return; }

            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') core.setFailed(`${workflowFile} concluded: ${run.conclusion}`);
                return;
              }
              await wait(pollEvery);
            }
            core.setFailed(`Timed out waiting for ${workflowFile} to complete`);

  # D. CODEBERG SYNC
  dispatch_codeberg:
    name: Dispatch codeberg.yml and wait
    runs-on: ubuntu-latest
    needs: dispatch_build
    steps:
      - name: Dry-run no-op (codeberg)
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait (codeberg.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        env:
          WORKFLOW_FILE: .github/workflows/codeberg.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER, repo = process.env.REPO, ref = process.env.REF;
            const workflowFile = process.env.WORKFLOW_FILE;
            const wait = ms => new Promise(res => setTimeout(res, ms));
            const timeoutMs=30*60*1000, pollEvery=10000, deadline=Date.now()+timeoutMs;
            const startAtIso = new Date().toISOString();

            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflowFile, ref, inputs: {} });

            let runId = null;
            while (Date.now() < deadline && !runId) {
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRuns,
                { owner, repo, workflow_id: workflowFile, event: 'workflow_dispatch', branch: ref, per_page: 50 }
              );
              const candidate = runs.find(r => new Date(r.created_at) >= new Date(startAtIso));
              if (candidate) runId = candidate.id; else await wait(pollEvery);
            }
            if (!runId) { core.setFailed(`Timed out waiting for ${workflowFile} run`); return; }

            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') core.setFailed(`${workflowFile} concluded: ${run.conclusion}`);
                return;
              }
              await wait(pollEvery);
            }
            core.setFailed(`Timed out waiting for ${workflowFile} to complete`);

  # E. CODEBERG RELEASE
  dispatch_codeberg_release:
    name: Dispatch codeberg_release.yml and wait
    runs-on: ubuntu-latest
    needs: dispatch_codeberg
    steps:
      - name: Dry-run no-op (codeberg_release)
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg_release.yml on ref ${{ env.REF }}"

      - name: Dispatch and wait (codeberg_release.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v7
        env:
          WORKFLOW_FILE: .github/workflows/codeberg_release.yml
        with:
          github-token: ${{ github.token }}
          script: |
