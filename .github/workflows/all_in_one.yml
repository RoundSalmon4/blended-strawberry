# ============================================================
# BLENDED-STRAWBERRY CI/CD ORCHESTRATOR — QUICK START GUIDE
#
# This orchestrator runs these workflows in order:
#   update → modify_git_revision → build → codeberg → codeberg_release → codeberg_notes → reset_git_revision
#
# ---------- GLOBAL VARIABLES (set once in GitHub) ----------
# Go to: Settings → Secrets and variables → Actions → Variables
#
# 1) NO_SIDE_EFFECTS
#    - true  = Workflows run fully, but SKIP pushes / release creation / codeberg sync / notes updates.
#    - false = Workflows perform real pushes/releases/syncs.
#
# 2) BLOCK_PUSH_TO_MASTER
#    - true  = Prevents any workflow using a git push from pushing to master accidentally.
#    - false = Allows pushes to master (production).
#
# ---------- RUN MODES ----------
#
# MODE A — DRY RUN ONLY (PLAN MODE)
#   dry_run = true
#   test_mode = false
#   → No workflows dispatched.
#   → Workflow prints “Would dispatch…” messages only.
#   → No side effects.
#
# MODE B — DRY RUN + INTENTIONAL FAILURE
#   dry_run = true
#   test_mode = true
#   → Same as above, but orchestrator FAILS at the end on purpose.
#
# MODE C — FULL TEST RUN (SAFE MODE)  *** MOST IMPORTANT MODE ***
#   dry_run = false
#   test_mode = true
#   NO_SIDE_EFFECTS = true   (repo variable)
#   → All workflows are actually dispatched.
#   → All build steps run (CMake, compile, downloads, loops, merges).
#   → All side-effecting steps are SKIPPED, with visible “[TEST]” messages.
#   → Orchestrator FAILS at the end intentionally so branch protections do not treat run as “production”.
#   → Zero risk: no pushes, no releases, no notes posted.
#
# MODE D — FULL PRODUCTION RUN
#   dry_run = false
#   test_mode = false
#   NO_SIDE_EFFECTS = false
#   BLOCK_PUSH_TO_MASTER = false (optional)
#   → Real CI/CD: runs everything and performs all side effects.
#   → Pushes happen.
#   → Codeberg release is created.
#   → Assets uploaded.
#   → Notes synced.
#   → Final result: SUCCESS.
#
# ---------- BEST PRACTICES ----------
# • For safe end‑to‑end testing, always use MODE C.
# • For checking orchestrator logic only, use MODE A.
# • For actual releases, use MODE D.
# • Leave BLOCK_PUSH_TO_MASTER=true unless you are 100% sure you want to write to master.
#
# ============================================================
name: All-in-One Orchestrator

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: "TEST MODE: Intentionally fail after everything runs (prevents successful completion)."
        type: boolean
        required: false
        default: false
      dry_run:
        description: "DRY RUN: Do not dispatch downstream workflows; only print what would happen."
        type: boolean
        required: false
        default: true

permissions:
  actions: write   # dispatch / inspect workflow runs
  contents: write  # inline jobs could write if you later add commits
  checks: read
  deployments: write

env:
  TEST_MODE: ${{ inputs.test_mode }}
  DRY_RUN: ${{ inputs.dry_run }}
  OWNER: RoundSalmon4
  REPO: blended-strawberry
  REF: master

jobs:
  echo_flags:
    name: Echo flags
    runs-on: ubuntu-latest
    steps:
      - name: Echo TEST_MODE and DRY_RUN
        run: |
          echo "TEST_MODE=${{ env.TEST_MODE }}"
          echo "DRY_RUN=${{ env.DRY_RUN }}"
          echo "REF=${{ env.REF }}"

  validate_files:
    name: Validate workflow files exist on ref
    runs-on: ubuntu-latest
    needs: echo_flags
    steps:
      - name: Checkout repo at REF
        uses: actions/checkout@v6
        with:
          ref: ${{ env.REF }}
          fetch-depth: 1
      - name: List workflows (depth 2)
        run: |
          echo "Repo root: $(pwd)"
          echo "Files under .github/workflows:"
          find .github/workflows -maxdepth 2 -type f -print | sort || true
      - name: Check required files
        shell: bash
        run: |
          set -e
          missing=0
          for f in \
            ".github/workflows/update.yml" \
            ".github/workflows/build.yml" \
            ".github/workflows/codeberg.yml" \
            ".github/workflows/codeberg_release.yml" \
            ".github/workflows/codeberg_notes.yml"
          do
            if [ -f "$f" ]; then
              echo "[OK] Found $f"
            else
              echo "[MISSING] $f"
              missing=1
            fi
          done
          if [ $missing -ne 0 ]; then
            echo "::warning::One or more required workflow files are missing on ref '${{ env.REF }}'. Dry-run will still proceed, but real dispatch will fail."
          fi

  dispatch_update:
    name: A) update.yml
    runs-on: ubuntu-latest
    needs: validate_files
    steps:
      - name: "[DRY RUN] Would dispatch .github/workflows/update.yml on ref ${{ env.REF }}"
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/update.yml on ref ${{ env.REF }}"
      - name: Dispatch and wait (update.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v8
        env:
          WORKFLOW_FILE: .github/workflows/update.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = process.env.OWNER;
            const repo  = process.env.REPO;
            const ref   = process.env.REF;
            const wf    = process.env.WORKFLOW_FILE;
            const wait = ms => new Promise(r => setTimeout(r, ms));
            const timeout = 30*60*1000, poll=10000, dl=Date.now()+timeout;
            const startAt = new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: wf, ref, inputs: {} });
            let runId=null;
            while(Date.now()<dl && !runId){
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRuns,
                { owner, repo, workflow_id: wf, event:'workflow_dispatch', branch: ref, per_page: 50 }
              );
              const c = runs.find(r => new Date(r.created_at) >= new Date(startAt));
              if (c){ runId=c.id; core.info(`run=${runId}`); break; }
              await wait(poll);
            }
            if(!runId){ core.setFailed(`Timed out waiting for ${wf} run`); return; }
            while(Date.now()<dl){
              const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if(run.status==='completed'){ if(run.conclusion!=='success') core.setFailed(`${wf} concluded: ${run.conclusion}`); return; }
              await wait(poll);
            }
            core.setFailed(`Timed out waiting for ${wf} to complete`);

  modify_git_revision:
    name: B) Modify Git Revision
    runs-on: ubuntu-latest
    needs: dispatch_update
    steps:
      - name: "[DRY RUN] Would modify cmake/Version.cmake to set INCLUDE_GIT_REVISION=OFF"
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would modify cmake/Version.cmake to set INCLUDE_GIT_REVISION=OFF"
      - name: Checkout repository
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/checkout@v6
        with:
          ref: ${{ env.REF }}
      - name: Apply change
        if: ${{ env.DRY_RUN != 'true' }}
        shell: bash
        run: |
          sed -i 's/set(INCLUDE_GIT_REVISION ON)/set(INCLUDE_GIT_REVISION OFF)/' cmake/Version.cmake
          echo "Modified Version.cmake (no commit/push here)."

  dispatch_build:
    name: C) build.yml
    runs-on: ubuntu-latest
    needs: modify_git_revision
    steps:
      - name: "[DRY RUN] Would dispatch .github/workflows/build.yml on ref ${{ env.REF }}"
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/build.yml on ref ${{ env.REF }}"
      - name: Dispatch and wait (build.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v8
        env:
          WORKFLOW_FILE: .github/workflows/build.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner=process.env.OWNER, repo=process.env.REPO, ref=process.env.REF, wf=process.env.WORKFLOW_FILE;
            const wait=ms=>new Promise(r=>setTimeout(r,ms));
            const timeout=30*60*1000, poll=10000, dl=Date.now()+timeout;
            const startAt=new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: wf, ref, inputs:{} });
            let runId=null;
            while(Date.now()<dl && !runId){
              const runs=await github.paginate(github.rest.actions.listWorkflowRuns,{ owner, repo, workflow_id:wf, event:'workflow_dispatch', branch:ref, per_page:50 });
              const c=runs.find(r=>new Date(r.created_at)>=new Date(startAt));
              if(c){ runId=c.id; core.info(`run=${runId}`); break; }
              await wait(poll);
            }
            if(!runId){ core.setFailed(`Timed out waiting for ${wf} run`); return; }
            while(Date.now()<dl){
              const { data: run }=await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if(run.status==='completed'){ if(run.conclusion!=='success') core.setFailed(`${wf} concluded: ${run.conclusion}`); return; }
              await wait(poll);
            }
            core.setFailed(`Timed out waiting for ${wf} to complete`);

  dispatch_codeberg:
    name: D) codeberg.yml
    runs-on: ubuntu-latest
    needs: dispatch_build
    steps:
      - name: "[DRY RUN] Would dispatch .github/workflows/codeberg.yml on ref ${{ env.REF }}"
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg.yml on ref ${{ env.REF }}"
      - name: Dispatch and wait (codeberg.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v8
        env:
          WORKFLOW_FILE: .github/workflows/codeberg.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner=process.env.OWNER, repo=process.env.REPO, ref=process.env.REF, wf=process.env.WORKFLOW_FILE;
            const wait=ms=>new Promise(r=>setTimeout(r,ms));
            const timeout=30*60*1000, poll=10000, dl=Date.now()+timeout;
            const startAt=new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: wf, ref, inputs:{} });
            let runId=null;
            while(Date.now()<dl && !runId){
              const runs=await github.paginate(github.rest.actions.listWorkflowRuns,{ owner, repo, workflow_id:wf, event:'workflow_dispatch', branch:ref, per_page:50 });
              const c=runs.find(r=>new Date(r.created_at)>=new Date(startAt));
              if(c){ runId=c.id; core.info(`run=${runId}`); break; }
              await wait(poll);
            }
            if(!runId){ core.setFailed(`Timed out waiting for ${wf} run`); return; }
            while(Date.now()<dl){
              const { data: run }=await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if(run.status==='completed'){ if(run.conclusion!=='success') core.setFailed(`${wf} concluded: ${run.conclusion}`); return; }
              await wait(poll);
            }
            core.setFailed(`Timed out waiting for ${wf} to complete`);

  dispatch_codeberg_release:
    name: E) codeberg_release.yml
    runs-on: ubuntu-latest
    needs: dispatch_codeberg
    steps:
      - name: "[DRY RUN] Would dispatch .github/workflows/codeberg_release.yml on ref ${{ env.REF }}"
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg_release.yml on ref ${{ env.REF }}"
      - name: Dispatch and wait (codeberg_release.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v8
        env:
          WORKFLOW_FILE: .github/workflows/codeberg_release.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner=process.env.OWNER, repo=process.env.REPO, ref=process.env.REF, wf=process.env.WORKFLOW_FILE;
            const wait=ms=>new Promise(r=>setTimeout(r,ms));
            const timeout=30*60*1000, poll=10000, dl=Date.now()+timeout;
            const startAt=new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: wf, ref, inputs:{} });
            let runId=null;
            while(Date.now()<dl && !runId){
              const runs=await github.paginate(github.rest.actions.listWorkflowRuns,{ owner, repo, workflow_id:wf, event:'workflow_dispatch', branch:ref, per_page:50 });
              const c=runs.find(r=>new Date(r.created_at)>=new Date(startAt));
              if(c){ runId=c.id; core.info(`run=${runId}`); break; }
              await wait(poll);
            }
            if(!runId){ core.setFailed(`Timed out waiting for ${wf} run`); return; }
            while(Date.now()<dl){
              const { data: run }=await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if(run.status==='completed'){ if(run.conclusion!=='success') core.setFailed(`${wf} concluded: ${run.conclusion}`); return; }
              await wait(poll);
            }
            core.setFailed(`Timed out waiting for ${wf} to complete`);

  dispatch_codeberg_notes:
    name: F) codeberg_notes.yml
    runs-on: ubuntu-latest
    needs: dispatch_codeberg_release
    steps:
      - name: "[DRY RUN] Would dispatch .github/workflows/codeberg_notes.yml on ref ${{ env.REF }}"
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would dispatch .github/workflows/codeberg_notes.yml on ref ${{ env.REF }}"
      - name: Dispatch and wait (codeberg_notes.yml)
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/github-script@v8
        env:
          WORKFLOW_FILE: .github/workflows/codeberg_notes.yml
        with:
          github-token: ${{ github.token }}
          script: |
            const owner=process.env.OWNER, repo=process.env.REPO, ref=process.env.REF, wf=process.env.WORKFLOW_FILE;
            const wait=ms=>new Promise(r=>setTimeout(r,ms));
            const timeout=30*60*1000, poll=10000, dl=Date.now()+timeout;
            const startAt=new Date().toISOString();
            await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: wf, ref, inputs:{} });
            let runId=null;
            while(Date.now()<dl && !runId){
              const runs=await github.paginate(github.rest.actions.listWorkflowRuns,{ owner, repo, workflow_id:wf, event:'workflow_dispatch', branch:ref, per_page:50 });
              const c=runs.find(r=>new Date(r.created_at)>=new Date(startAt));
              if(c){ runId=c.id; core.info(`run=${runId}`); break; }
              await wait(poll);
            }
            if(!runId){ core.setFailed(`Timed out waiting for ${wf} run`); return; }
            while(Date.now()<dl){
              const { data: run }=await github.rest.actions.getWorkflowRun({ owner, repo, run_id: runId });
              if(run.status==='completed'){ if(run.conclusion!=='success') core.setFailed(`${wf} concluded: ${run.conclusion}`); return; }
              await wait(poll);
            }
            core.setFailed(`Timed out waiting for ${wf} to complete`);

  reset_git_revision:
    name: G) Reset Git Revision
    runs-on: ubuntu-latest
    needs: dispatch_codeberg_notes
    steps:
      - name: "[DRY RUN] Would restore cmake/Version.cmake to set INCLUDE_GIT_REVISION=ON"
        if: ${{ env.DRY_RUN == 'true' }}
        run: echo "[DRY RUN] Would restore cmake/Version.cmake to set INCLUDE_GIT_REVISION=ON"
      - name: Checkout repository
        if: ${{ env.DRY_RUN != 'true' }}
        uses: actions/checkout@v6
        with:
          ref: ${{ env.REF }}
      - name: Apply change
        if: ${{ env.DRY_RUN != 'true' }}
        shell: bash
        run: |
          sed -i 's/set(INCLUDE_GIT_REVISION OFF)/set(INCLUDE_GIT_REVISION ON)/' cmake/Version.cmake
          echo "Modified Version.cmake (no commit/push here)."

  fail_if_test_mode:
    name: H) Fail run if TEST_MODE is true
    runs-on: ubuntu-latest
    needs:
      - dispatch_update
      - modify_git_revision
      - dispatch_build
      - dispatch_codeberg
      - dispatch_codeberg_release
      - dispatch_codeberg_notes
      - reset_git_revision
    if: always()
    steps:
      - name: Check TEST_MODE and optionally fail
        shell: bash
        run: |
          echo "TEST_MODE=${{ env.TEST_MODE }}"
          if [ "${{ env.TEST_MODE }}" = "true" ]; then
            echo "Global test mode enabled: intentionally failing at the end."
            exit 1
          else
            echo "Global test mode disabled: finishing successfully."
          fi
